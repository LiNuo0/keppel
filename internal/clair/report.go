/*******************************************************************************
*
* Copyright 2021 SAP SE
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You should have received a copy of the License along with this
* program. If not, you may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*******************************************************************************/

package clair

import (
	"encoding/json"
	"net/http"
	"strings"
)

//VulnerabilityReport is an image's vulnerability report as generated by Clair.
type VulnerabilityReport struct {
	Digest string `json:"manifest_hash"`
	//We only destructure a small amount of data in this report (exactly those
	//fields that we need for our own processing). Everything else gets passed on
	//to our API users verbatim.
	Packages               map[string]interface{}    `json:"packages,omitempty"`
	Distributions          map[string]interface{}    `json:"distributions,omitempty"`
	Repositories           map[string]interface{}    `json:"repository,omitempty"`
	Environments           map[string][]interface{}  `json:"environments,omitempty"`
	Vulnerabilities        map[string]*Vulnerability `json:"vulnerabilities,omitempty"`
	PackageVulnerabilities map[string][]string       `json:"package_vulnerabilities,omitempty"`
}

//VulnerabilityStatus returns the merged severity of all vulnerabilities in this report.
func (r VulnerabilityReport) VulnerabilityStatus() VulnerabilityStatus {
	sevs := make([]VulnerabilityStatus, 0, len(r.Vulnerabilities))
	for _, v := range r.Vulnerabilities {
		if v != nil {
			sevs = append(sevs, v.NormalizedSeverity)
		}
	}
	return MergeVulnerabilityStatuses(sevs...)
}

//Vulnerability appears in type VulnerabilityReport.
type Vulnerability struct {
	//all data relating to this vulnerability (for serializing into JSON)
	Contents map[string]interface{}
	//some individual fields from .Contents, prepared for internal processing
	NormalizedSeverity VulnerabilityStatus
}

//MarshalJSON implements the json.Marshaler interface.
func (v *Vulnerability) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.Contents)
}

//UnmarshalJSON implements the json.Unmarshaler interface.
func (v *Vulnerability) UnmarshalJSON(buf []byte) error {
	if v.Contents == nil {
		v.Contents = make(map[string]interface{})
	}
	err := json.Unmarshal(buf, &v.Contents)
	if err != nil {
		return err
	}

	var parsed struct {
		NormalizedSeverity VulnerabilityStatus `json:"normalized_severity"`
	}
	err = json.Unmarshal(buf, &parsed)
	if err != nil {
		return err
	}

	v.NormalizedSeverity = parsed.NormalizedSeverity
	return nil
}

//GetVulnerabilityReport retrieves a vulnerability report for this manifest
//from Clair. `(nil, nil)` is returned in case of 404, i.e. if the manifest has
//not been fully indexed yet.
func (c *Client) GetVulnerabilityReport(digest string) (*VulnerabilityReport, error) {
	//if we faked the indexing report, we also need to fake the vulnerability
	//report (see comment in c.submitManifest())
	if c.isEmptyManifest[digest] {
		return &VulnerabilityReport{
			Digest:                 digest,
			Packages:               map[string]interface{}{},
			Distributions:          map[string]interface{}{},
			Repositories:           map[string]interface{}{},
			Environments:           map[string][]interface{}{},
			Vulnerabilities:        map[string]*Vulnerability{},
			PackageVulnerabilities: map[string][]string{},
		}, nil
	}

	req, err := http.NewRequest("GET", c.requestURL("matcher", "api", "v1", "vulnerability_report", digest), nil)
	if err != nil {
		return nil, err
	}
	var result VulnerabilityReport
	err = c.doRequest(req, &result)
	if err != nil && strings.Contains(err.Error(), "got 404 response") {
		return nil, nil
	}
	return &result, err
}
